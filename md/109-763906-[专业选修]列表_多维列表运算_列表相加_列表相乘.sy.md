---
show: step
version: 1.0
enable_checker: true
---

# 列表 - 深拷贝 deepcopy

## 回忆

- 上次我们了解了赋值的时候注意有三种情况
  - = 
	- 直接复制变量引用的地址
  - 浅拷贝 
	- 新建列表
	- 复制列表项的引用地址
  - 深拷贝 
	- 新申请空间
	- 彻底做一个新的副本
	- 把所有东西都复制出来
	- 这就是深拷贝所谓深的地方

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669712354030)

- 列表三种复制方法我们清楚了
- 如果是多维列表的运算呢？
- 内存中的样子是如何的呢？

### 直接相加

- 将相加结果进行赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669714963590)

- `l_people` + `l_people` 确实会分配一个新的列表空间
	- 新空间扩展两次 `l_people` 的列表项
	- 但是仅仅是列表引用地址的复制
	- 还是一改全改
	- 并不是真正的副本
- 启动深拷贝模式

### 深拷贝

- 从copy中导入deepcopy

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669715299295)

- 使用了deepcopy的部分分配了新的内存空间
- 没使用deepcopy就不分配

### 都用deepcopy

- deepcopy

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669715451325)

- 确实都分配了新的空间
- 那乘法呢？

### 乘法

- 直接乘法
	- 然后直接赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669715561284)

- 不用deepcopy都是直接引用地址

### 使用deepcopy

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669715790112)

- 新分配空间
	- 但是新空间重复引用
- 想要都分配新空间

### 还是得都用deepcopy

- deepcopy

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669715451325)

- 多维列表可以用乘法吗？

### 列表嵌套

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623493488)

- x 最开始是一个列表
  - 列表里面有一个列表
  - 内部列表有个元素是 0
- 然后 x 乘以 3
  - [[0],[0],[0]]
- x[0]是[0]
	- 添加 1 之后是[0,1]
- 可是为什么 
	- x[1]、x[2]也都是  [0,1]呢？

### 观察

- x =[[0]]

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623686937)

- x = x \* 3

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623716306)

- x 是一个列表
	- x 列表里面有三个元素
	- 三个元素都是列表
	- 都引用同一个列表地址
	- 这个被引用列表的值是x[0]
	- 我可以看到这个地址吗？

### 观察地址

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221130-1669774157923)

- 确实是引用同一个地址空间

### 附加 append

- 关键的一步来了

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623810957)

- x[0].append(1)
	- x[0] 附加 append 了 1
	- x[0]、x[1]、x[2]指向同一位置
- 所以 x 就是
  - [[0, 1], [0, 1], [0, 1]]
- 但是如果我一开始初始化 x 的方式为
  - x = [[0], [0], [0]]呢？

### 新情况

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211126-1637924664867)

- 这和刚才的这个完全不同啊？
- 为什么呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631623493488)

### 原因分析

- 因为x[0]、x[1]、x[2]引用同样的地址

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211126-1637924709657)

- 列表还有一种运算方式
	- 叫做缝合(zip)


### 缝合(zip)

- zip 可以把若干列表同一位置的元素压在一起

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669731361310)

- 把两个列表里同样位置的元素
	- 缝合在一起

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210915-1631698233000)


### 总结

- 我们了解到列表也可以进行运算
	- 加法运算
		- 会产生新的列表空间
		- 但是高维的列表引用还是被直接复制
		- 可以用深拷贝deepcopy制作全新高维列表
	- 乘法运算
		- 乘法的本质是累加
		- 默认的结果使用的是原来的列表引用
	- 缝合操作
		- 把两个列表里同样位置的元素
		- 缝合在一起

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669731361310)

- 缝合里面出现的小括号应该怎么理解呢？🤔
- 下次再说 👋
