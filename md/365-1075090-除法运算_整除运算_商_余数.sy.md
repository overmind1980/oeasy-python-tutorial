---
show: step
version: 1.0
enable_checker: true
---

# 负数表示

## 回忆

- 上次了解了divmod函数
	- 函数的返回值是一个元组
		- 前面的是 整除运算的结果
		- 后面的是 取余运算的结果
- 除数不能为零
	- 那如果除数是小数呢？🤪

## 动手

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629443935143)

- 除法 <kbd>/</kbd> 运算肯定是可以的
- 如果 <kbd>//</kbd> 运算呢？

### 整数除法 的 含义

- <kbd>//</kbd> 是整数除法

- 回忆
	- 整数乘法的 本质 是连加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230904-1693813970474)

- 除法的 本质 是连减
	- 47 减去 3 得 44
	- 44 减去 3 ...
	- 一共可以减15轮

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230904-1693814009349)

- 也就是 说 
	- 47个 分 3组
	- 每个 可以分 15个

### 莱布尼茨 计算器

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230904-1693824433438)

- 莱布尼茨计算器 就是 用这种方式
	- 47 - 3 - 3 ...
	- 最后 剩下 2

### 四则运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230904-1693824715541)

- 据称 二进制运算 来自于 伏羲易经的启发
	- 具体见当年原文
	- https://www.leibniz-translations.com/binary.htm

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230905-1693884692116)

- 论文中 提到了 二进制的四则运算
- 计算机是如何完成加减乘除的呢？

### 计算机的指令

- 计算机的cpu
	- 将 四则运算 设置为 内部电路的通断模式
	- 再将 内部通断模式 编码为 字节状态
- 接到 某个字节状态 比如BA
	- 将内部模式调整为加法器模式
	- 然后 根据寄存器中的 数字
	- 得到加法结果 放到寄存器里

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230906-1693965422593)

- 接到了 另外的字节状态 比如DD
	- 将内部模式调整为除法器模式
- 除了 整数除法 之外
	- 小数 可以做 除法吗？

### 小数整除

- 小数整除也是可以的
	- 3里面有13个0.23
		- 就是2.99

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221203-1670073315561)

- 结果是小数 float 类型的数字
- 数字是可以转化为整数的
- 小数除法可以取余么？

### 小数取余

- 小数取余 逻辑
	- 和整数 差不多

> 被除数 / 除数 = 商.....余数 

> 余数 = 被除数 - 除数 * 商

> 被除数 = 除数 * 商 + 余数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230619-1687170517841)

- 那负数呢？
- 负数可以整除取余数么？

### 负数整除取余数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629444422664)

- 好像可以回去
- 貌似能说通
- 可是为什么是-14.0
- 而不是-13.0

### 总结

- 这次 除法
	- 总共两种除法 
	- <kbd>/</kbd>  普通除法
	- <kbd>//</kbd> 整数除法

- 整除的时候遇到一个问题
	- 为什么 3 // -0.23 
		- 得到 -14.0 呢？ 🤪

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230904-1693814516320)

- 下次再说 👋
