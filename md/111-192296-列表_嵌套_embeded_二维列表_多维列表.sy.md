---
show: step
version: 1.0
enable_checker: true
---

# 列表 - 嵌套 embedded

## 回忆

- 上次我们 又了解了 排序
	- 最初的排序 list.sort
	- 乱序 list.shuffle
- 无序有序都用
	- 无序带来混乱的快乐
	- 有序带来理性的方便
- 新排序 sorted
	- 可以产生一个新的列表

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/3022416/uid1190679-20241108-1731031965491) 

- 目前 列表 都是 一维的 
- 可以 有`更高维度`的列表吗？ 🤔

### 去游乐场

- 分析append和extend的区别

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669691015206)

- append
	- 追加 列表项
- extend
	- 拓展 列表

### 例子

```
lst = []
lst.extend([0, 1])
lst
lst.append([0, 1])
lst
```

- 效果

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736858509166) 

- 这还是个列表吗？

### 观察

```
type(lst)
len(lst)
lst[0]
lst[1]
lst[2]
lst[3]
```

- lst确实还是列表
	- 总共有三个列表项的列表

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736858611651) 

- 第2个列表项是什么呢？

### 再观察

```
lst
lst[2]
type(lst[2])
len(lst[2])
lst[2][0]
lst[2][1]
```

- 第二个列表项 还是 
	- 一个列表
	- 2个元素的 列表

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736858858378) 

- lst是列表的列表？

### 套娃？

- 列表的列表

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669708520014)

- 容器的容器
	- 不就成了套娃🪆吗？
- 这个列表的列表项
	- 也能用索引来访问吗？

### 二维列表

- 原来的列表 
	- 属于一维列表

```python
lst = [
		[1, 2, 3],
		[4, 5, 6],
		[7, 8, 9] ]
lst 
lst[0]
```

- 这种列表的列表叫什么名字呢？

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736859015374) 

- 列表的列表
	- 属于二维列表
- 本来 lst 是一个 3\*3 的数组
	- 进行了 索引 [0]
	- 得到了 这个二维数组的 第一个元素
	- 一个 一维列表 [1, 2, 3]
	- 可以 进一步 进行索引 吗？

### 索引降维

```
lst
lst[0]
lst[0][0]
lst[0][1]
lst[0][2]
```

- 通过索引找到具体的列表项

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736859131217)

- 可以切片吗？

### 切片

```
lst[0]
lst[0][1:3]
lst[0][:2]
```

- 可以再对 a[0] 这个一维数组进行
  - 切片操作

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736859189942) 

-  这是 
	-  先索引
	- 再切片
- 那 我 可以
	- 先切片
	- 后索引 吗？

### 切片操作

```
lst
lst[0:2]
lst[0:2][1]
lst[0:2][1][0]
```

- 二维列表先切片
	- 得到的还是一个二维列表
    - 是按照行切出来的列表

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736860011166) 

- 可以连续切片吗？

### 连续切片

```
lst
lst[0:2]
lst[0:2][1:2]
lst[0:2][0:1]
```

- 再切片得到的还是二维列表
    - 切片 维持原来的维度

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736860334335) 

- 可以对这个二维列表
	- 切片是筛减
	- 索引是降维
- 可以用负数进行索引和切片吗？

### 负数

```
lst[-3:]
lst[-3:-1]
lst[-3:-1][-3:]
lst[-3:-1][-3:-1]
```

- 负数索引
	- 逻辑 和 一维一样
	- -1 最后一个
	- -len 第一个

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736860455606) 

- 实际的应用？

### 音符 和 乐句

- 话要 一句一句说
	- 中间有喘气的 时间
	- 音乐里面 也有气口
	- 叫做 乐句

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20250404-1743769080976)

- 音乐由 6个小乐句 构成
	- 每个乐句的结尾 有停顿

```
from mido import Message, MidiFile, MidiTrack

mid = MidiFile()
track = MidiTrack()
mid.tracks.append(track)

# 定义小星星的音符（C 大调）
notes = [
    ['C4', 'C4', 'G4', 'G4', 'A4', 'A4', 'G4'],
    ['F4', 'F4', 'E4', 'E4', 'D4', 'D4', 'C4'],
    ['G4', 'G4', 'F4', 'F4', 'E4', 'E4', 'D4'],
    ['G4', 'G4', 'F4', 'F4', 'E4', 'E4', 'D4'],
    ['C4', 'C4', 'G4', 'G4', 'A4', 'A4', 'G4'],
    ['F4', 'F4', 'E4', 'E4', 'D4', 'D4', 'C4']
]

# 音符映射到 MIDI 音高
note_map = {
    'C4': 60, 'D4': 62, 'E4': 64, 'F4': 65, 'G4': 67, 'A4': 69, 'B4': 71,
    'C5': 72
}

# 设定节奏（四分音符时值为 480）
duration = 480
pause_duration = 480  # 句间停顿时间
fade_out_time = 480  # 过渡时间

for phrase in notes:
    for note in phrase:
        midi_note = note_map[note]
        track.append(Message('note_on', note=midi_note, velocity=64, time=0))
        track.append(Message('note_off', note=midi_note, velocity=64, time=duration))

    # 让停顿过渡自然，使用逐渐减弱的音量
    track.append(Message('note_off', note=0, velocity=32, time=fade_out_time))
    track.append(Message('note_off', note=0, velocity=0, time=pause_duration - fade_out_time))

mid.save("twinkle_twinkle_star.mid")
print(f"MIDI 文件已保存为 twinkle star")
```

- 能找出乐段

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250404-1743768362148) 


- 如果列表超过了二维
	- 索引和切片还是这样吗？

### 设置时长

```
```

### 多维列表

```
lst = [0, [1, [2, 3]]]
lst 
len(lst)
lst[0]
lst[1]
lst[1][0]
lst[1][1]
lst[1][1][0]
lst[1][1][1]
```

- 多维列表
	- 索引和切片的模式
	- 没有变

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736860604734) 

- 多维列表 可以 排序吗？

### 排序前提

- 排序的前提是能够比较大小

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231205-1701782816543)

- 列表型不能和整型比较
- 列表型可以和列表型比较吗？

### 尝试比较

```
[0] < [1]
[0] > [1]
lst = [[3], [2], [1]]
lst.sort()
lst
```

- 同一维度的列表对象可以比较

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736860703999) 

- 特定的列表对象可以排序

### 列表比较

```
lst = [[1, 0], [0, 1]]
lst[0] < lst[1]
lst[0] > lst[1]
```

- 排序的前提是比较
	- 列表是可以进行比较的

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736860848963) 

- 那列表比较的原则是什么呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669717604263)

- 先比较第0个元素
	- 如果不同
		- 就得出结论
	- 如果相同
		- 再比较第1个元素
	- 以此类推

- 排序后 列表地址变了吗？

### 构造

```
l1 = [[1, 2], [2, 3], [0, 1]]
l1.sort()
```

- 排序前
	- https://pythontutor.com/render.html#mode=display 

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736861382126) 

- 排序后

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736861403178)

- 列表地址有变化吗？

### 列表地址

```
l1 = [[1, 2], [2, 3], [0, 1]]
print(id(l1))
l1.sort()
print(id(l1))
```

- 排序后的列表还是在那个位置

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736861483034) 

- 切片地址有变化吗？

### 观察内存

```
l1 = [[1, 0], [0, 1]]
print(id(l1[0]),id(l1[1]))
l1.sort()
print(id(l1[0]),id(l1[1]))
```

- 切片本身地址 不变
	- 排序排的是 
	- 存放切片引用的 列表项位置

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736861807032) 

- 多维列表的列表项可以排序吗？

### 列表项排序

```
l1 = [[1, 0], [0, 1]]
print(id(l1[0]),id(l1[1]))
l1[0].sort()
l1
print(id(l1[0]),id(l1[1]))
```

- 结果

![图片描述](https://doc.shiyanlou.com/courses/3584/labs/192296/uid1190679-20250114-1736862000164) 

- 列表项l[0]
	- 还可以进行排序的
	- 排序不影响列表自身的地址

### 总结

- 这次 我们 了解了列表的 嵌套(embedded)
	- 列表项 也可以是 列表
	- 可以 无限嵌套 下去
- list.sort
	- 不会改变 列表的 位置
	- 也不会改变 列表切片的 位置
	- 改的只是 引用地址 在列表 中的位置


![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221129-1669708577034)

- 除了list.sort之外
	- 排序的方法
	- 还有内建的sorted
	- 有什么`区别` 来着？🤔
- 下次再说 👋
