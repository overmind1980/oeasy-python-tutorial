---
show: step
version: 1.0
enable_checker: true
---

# 列表 - 构造

## 回忆

- 上次了解了列表的索引
- 可以用中括号加索引找到相应的元素
- 也可以用 index 找到元素的位置
- 还可以用 count 找到元素的匹配数量
- 列表中的元素可以进行什么样的计算么？🤔

### 回忆字符串

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630203640962)

- 字符串可以进行加法和乘法的运算
- 但是这个到底是什么样的过程呢
- 去一个网站观察
- Start visualizing

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630203709851)

### 选择

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630208623942)

- 点击 Live Programming Mode
- 然后进入到试试编程模式

### 字符串运算

- 这种直接的计算
- 并不能为内存中的变量赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209077502)

- 在左边的 frames 的位置是空的
- 现在尝试赋值

### 赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209062770)

- 有两个变量在 Stack 栈空间有了 Frames
- 可以用 prev 和 next 控制流程运行
- 数字型变量的情况呢？

### 数字变量

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209240049)

- 可以看到数字变量都在帧栈空间
- 那么列表 list 变量呢？

### 列表变量

- 可以看到 l 变量在帧栈上有一个位置
- 这个位置里面存储的是 list 在堆 Heap 空间上的地址
- 从这个位置可以找到 Heap 堆空间的位置
- 堆空间里面存储着具体的列表元素
- 栈空间存储着堆空间的地址引用

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209428885)

- 注意那条带箭头的线
- 左边的变量在 Frames 中
- 引用着右边 Heap 空间中的内容

### 空列表

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209485488)

- 把空列表赋给 l
- l 仍然在栈空间
- l 仍然指向堆空间
- l 指向堆空间一个新的空列表
- 原来的列表没有被任何变量所指
- 会被垃圾回收

### None

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630209628126)

- 把 None 赋给 l
- l 仍然在栈空间
- l 不指向堆空间
- 堆空间里面刚才的空列表没有被任何变量所指
- 会被垃圾回收
- 那我们来看看列表的赋值运算

### 分别赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210333943)

- l1、l2 是两个不同的列表
- 虽然都指向 list("oeasy")
- 但是在堆空间是两个不同的 list
- 各是各的
- 那什么叫不是各是各的呢？

### 用列表赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210495419)

- l2 = l1
- 让 l2 指向 l1 所指向的堆空间的 list 对象
- 这样不论是 l1 还是 l2
- append 都会统一地在那个堆空间下添加列表项
- 如果我想要让 l2 的内容和 l1 相等
- 但是分别指向不同的堆空间
- 应该如何呢？

### getrefcount

- 这个函数可以得到 heap 中空间到底由几个变量进行引用

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830125600)

- 明明是 l1、l2 两个变量啊
- 查看帮助

### 帮助手册

- 本来确实应该是两个
- 但是由于这个函数调用的时候
- 在函数内部还有一个参数变量也引用了这个位置
- 所以会比想象地变量多 1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830139942)

### copy 函数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210731635)

- 返回列表的浅拷贝
- 试试

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210778781)

- 拷贝明白了
- 分别的指向两个列表位置
- 浅是什么意思
- 还不清楚
- 再试试其他运算

### 加法运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210864598)

- 首先是可以加的
- 但是加的结果没有赋给任何变量
- 就在寄存器的风中
- 消失了

### 加法并赋值

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210997707)

- 把加法的结果赋给 l3
- l1、l2、l3 三个变量指向不同的堆对象地址
- 可以把这个东西赋给 l1 么？

### 赋值细节

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211221361)

- 加法运算是先复制 l1 里面的元素
- 然后追加 l2 里面的元素
- 可以把加法运算的结果赋给 l1
- l1 原来所指向的 list 列表就没有人引用了
- 空间会被系统回收
- 能否直接在 l1 之后进行追加

### 列表追加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631580147683)

- 这里使用切片 a[3:]
- 其实就是在 a 的最后一个元素后面再追加列表 b
- 然后 a 就是被扩展 extend 了
- 这个时候其实有个新函数 extend

### extend

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211311655)

- extend 是把参数里面的列表项循环地放到主体上
- 效率更高

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211378376)

- 而加法运算是新建一个列表
- 然后把 l1 的列表项都拿过来
- 再把 l2 的列表项都拿过来
- 最后把相加结果赋给 l1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630211451887)

- 那这个 extend 和 append 有什么区别呢？

### 区别

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210914-1631579842400)

- 操作对象不同
- append 添加的是具体的元素
- extend 是追加另一个列表
- 我们再试试乘法运算

### 乘法

- 乘法的本质就是累加

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630222596114)

- 本质就是在 heap 区生成一个新的列表
- 然后把这个列表的实际地址
- 赋给一个在 stack 区的列表对象

### 空列表

- 如果本身就是空列表
- 列表里面没有列表项
- 乘多少还是空的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630241238365)

- 但如果这里面有东西
- 乘出来列表项就翻倍了
- 即使里面是空列表
- 空列表也翻倍

### 总结

- 这次我们了解了列表的运算
- 赋值运算
  - 本质是把 heap 区中的列表对象地址付给对方
  - 可以用 copy 新建一个浅 copy 再赋给变量
  - 拷贝是明白了
  - 不过浅是什么意思还不清楚
- 加法
  - 加法的本质是在 heap 区中新建列表完成加法
  - =把加法的结果赋给变量
  - 也可以用 extend 在当前列表位置继续添加列表项
- 乘法
  - 乘法的本质是累加
  - 结果也是放在 heap 区
  - 可以被赋值给变量
- 加法乘法都是让列表变长
- 可以让列表变短吗？🤔
- 下次再说 👋
