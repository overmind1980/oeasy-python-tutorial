---
show: step
version: 1.0
enable_checker: true
---

# 程序本质

## 回忆上次内容

- `python3` 的程序是一个 5.3M 的可执行文件
  - 我们通过which命令找到这个python3.8的位置
  - 将这个python3.8复制到我们的用户目录下
  - 这个文件还是能够执行的
- 将这个文件转化为字节形态
  - 确实可以转化
  - 但是这个文件我们看不懂啊！！！😭

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220928-1664341476073)

- 怎么才能看懂这些东西呢？🤔

- 这个东西我们确实看不懂
- 但是有人能看懂
- 谁呢？

### 真实的cpu

- 无论手机还是计算机
	- 最核心器件的器件就是cpu

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220916-1663336715763)

- 这个东西是个实实在在存在的实体
- 我们所说的python虚拟机能看到么？

### cpu

- cpu能看懂这些字节码！！！
- 这些我们看不懂的字节码
	- cpu能看懂
	- 这是属于cpu的机器语言
	- 这就是cpu的一条条的机器指令(instruction)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663378288126)

- 机器指令码都是二进制字节形式的
- 我们尝试把python3.8转化为字节表现形式

### 反汇编-汇编语言助记符

```shell
#先把~/python3对应的机器语言输出为汇编指令形式(反汇编)
objdump -d python3.8 > python3.8.asm
vi python3.8.asm
```

- 这次真的可以看懂了
	- 减法(sub)
	- 移动(mov)
	- 这些指令

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663379169504)

- 可以发现当前系统的架构(指令集)是x86-64
- 这些和我们刚才的字节形态有关系吗？

### 对比

- 用vi分窗口分别打开打开python3 和 python3.asm

```
vi -o python3.8hex python3.8.asm
```

- 下图中上半部分是机器语言

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663379690713)

- 上图下半部分是机器语言对应的汇编指令助记符
- <kbd>ctrl</kbd>+<kbd>j</kbd>、<kbd>ctrl</kbd>+<kbd>k</kbd>可以上下切换
- 我们来试着找找
	- python3文件中
	- 机器语言的0101和cpu的汇编指令的对应关系🧐

### 找到了

- 先跳过下面窗格的第8行
	- endbr64 意味着 64位结束分支
	- 下面的sub执行的是减法

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220326-1648272884431)


- 下面窗格的 第9行
	- `/48 83` 找到上下的对应关系
	- 也就是第一条执行的汇编指令减法(sub)
	- 汇编指令是计算机 cpu 机器指令的助记符

### 查找对应关系

- `423000` 就是初始化(init)的 cpu 开始执行指令的地址
- 我们在上面查找48 83 有没有对应的字节
	- /4883 ec08 488b...
	- 在上面的窗格中
	- 搜索这些字节形态

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663380044343)

- 好像找到了对应关系
- 具体怎么对应的呢？
- 这台计算机用的是什么指令集呢？
- 什么是指令集来着？

### 指令集

- 指令集就是指令的集合

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663380788566)

- 指令集也叫计算机的架构
- 不同架构的 cpu 有不同的指令集
  - 我们目前的这个浏览器里面的系统用的是 `x86-64`
  - 除此之外 `arm`、`MIPS`、`RISC-V` 也是常用的指令集
- 指令助记符和机器语言到底是则怎么对应的呢？

### 回到代码

- 代码会有不同的 `section` 模块
	- 入口是 `init`
	- 作用是初始化`initialization`

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663381072650)

- 模块里面是具体的指令
	- 比如第一句 `48 83 ec 08`
- 为什么48 83 就可以代表减法
- 这是谁规定的呢？

### 查看指令集

- 这是cpu架构规定的
	- 首先要明确到当前机器cpu的架构
	- 反汇编里面说是x86-64


![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220930-1664542482946)

- 到shell里面验证一下

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663381203502)

- 当前机器所用的架构指令集确实是x86_64
- 这是谁的架构呢？

### 搜索

- 不会了就去搜索😄

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663381542216)

- 去intel官网找指令集

### 查询x86_64指令集

- 找到cpu的手册
	- https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf

- 可以找到指令和二进制状态之间的关系么？
	- 先要找到x86-64指令集中 48 83 这条指令

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663381754779)

- 注意上图中
	- 100B中的B是0或1
	- 100B可以是1000
	- 也可以是1001
- 这确实是一条减法指令
	- 而且是8位立即数和寄存器的减法运算

### 逐步搜索

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220326-1648273501937)

- 找起来真的很费劲
	- `48 83 ec 08` 对应 `sub $0x8,%rsp`
	- 确实是一条减法指令
	- 确实是8位立即数和寄存器的减法运算

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663381867033)

- 和objdump的结果是一致的
	- 废话！！！😠

- 除了减法指令sub之外
- 还有什么别的指令呢？

### 各种cpu指令

- 指令那可还有很多的
	- 有运算的
	- 有移位的
	- 加减乘除都有

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210303-1614752112519)

- 这些指令的集合就是指令集
	- 指令集就是cpu运行的基础！
- 这些机器语言的指令不能在别的指令集架构上运行么？

### 移植 port

- 想在别的指令集架构上运行程序
	- 就需要移植(port)
	- 移植(port)指的是从一种指令集移植到另一种指令集
- 从这个词的词源
	- 可以看出欧美的航海文化基础 
		- port 港口
	- 也可以看出我们的农耕文化基础
		- 移植

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210916-1631768738175)

- 不移植会如何呢？

### 不移植

- 这是playstation2的架构图
	- cpu是mips架构的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220930-1664537109817)

- 不移植的话
	- 就是让x86架构的pc
	- 去直接执行这些基于mips架构的的0101... 字节码
- 就像让一个意大利泥瓦匠看一份中文写成的烹饪书来砌墙
    - 鸡同鸭讲
    - 驴唇不对马嘴
    - 0101的文件执行出来全是乱的
	- 完全不能用
- 而且不全是软件的问题
	- 也涉及到硬件等方面
	- 可能某个寄存器在新架构中根本就不存在

### 架构师

- 这个时候架构师要解决相当多的问题
- 很不容易的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220930-1664542189137)

- 落实到我们的python3.8游乐场
	- 我们的python3.8就是这样的一系列的cpu指令
	- 可以解释py文件的
- python3.8 又是如何解释py文件的来着？

### python3 执行过程

- 不管是python3这个游乐场
- 还是hello.py这个python程序
- 都在我们的硬盘上

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220928-1664343253858)

- 先得把文件从硬盘读到内存

### python3 执行的过程大致是这样

- 先把python3.8这个主解释器加载到内存中
	- 然后在x86-64的cpu上执行
	- 模拟出一台python虚拟机

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210810-1628603452610)

- 对py文件解释执行
- 那为什么py程序可以跨架构跨平台呢？

### 架构的层次

- 不同架构的 cpu 都可以运行 python
  - risc-v
  - arm
  - x64
  - mips
  - 龙芯

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220930-1664529847821)

- 不同系统的环境都可以运行 python
  - win
  - mac
  - linux
  - freebsd

### 跨架构跨平台原理

- 由于python3可以运行在不同的cpu架构和系统上
	- 所以同样的py文件被加载之后
	- python程序可以对py文件跨架构、跨系统进行解释执行
	- 一次编写到处运行

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220917-1663382940108)

- 不同的架构
	- 二进制的python程序对应的汇编指令都不一样
	- 怎么能正确解释执行同样的python程序呢？

### 跨架构跨平台原理

-  `/usr/bin/python3.8` 本身是二进制文件
	- 是基于当前操作系统当前架构编译出来的
		- 可执行二进制文件
	- 不同的架构有不同的编译器
	- 不同的编译器编译出来的python3.8
	- 是不同的二进制指令序列

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220727-1658929621691)

- `python3.8` 构建了一个运行时环境
	- 这个环境可以解释读到的`python语句`
	- 把`python语句`翻译成系统能读懂输入输出
	- 翻译成当前架构能够执行的代码
- 然后边解释边执行
- 恭喜您完成了非常烧脑一个实验！
- 我们去总结吧！！！

## 总结

- `python3` 的程序是一个 5.3M 的可执行文件
  - `python3` 里面全都是 cpu 指令
  - 可以执行的那种
  - 我们可以把指令对应的汇编找到
	- `objdump -d ~/python3 > python3.asm`
- 汇编语句是和当前机器架构的指令集相关的
	- `uname -a`可以查询指令集
- 我们执行的过程其实就
  - 系统执行`python3`这个可执行文件
  - 给了`python3`一个参数`hello.py`
  - `python3`对于`hello.py`一句句的解释执行
  - 在显示器输出了`hello world`
  - `python3`执行完毕
  - 把控制权交回给 shell
- 这就是我们执行`hello.py`的过程
- 我想输出个稍微复杂点的东西
	- 可以做下面这个框架标题吗？🤔

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210307-1615080578652)

- 我们下次再说！👋
