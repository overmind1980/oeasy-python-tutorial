---
show: step
version: 1.0
enable_checker: true
---

#  使用ajax异步的方式实现更新功能_update_更新数据库记录

## 回忆上次

- 上次完成了异步更新的功能
	1. 首先从里浏览器发出一个PUT的异步请求
	2. 后台接到请求后从数据库更新记录并返回异步请求的响应
	3. 浏览器接到相应后再异步发出一个查询请求
	4. 后台接到异步查询请求后，在数据库中查询，并返回json
	5. 浏览器接到json并且在页面进行展示
- 这次CRUD完整啦！
	- 增加(Create)
	- 读取(Read)
	- 更新(Update)
	- 删除(Delete)

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20230528-1685234785569)

- 究竟应该如何理解CRUD呢？

### CRUD 发展历史

- CRUD 问世于 20 世纪 80 年代
	- 用于描述 SQL 中的数据库基本操作
- 首次提及是
	- 1990 年 
	- Haim Kilov 的文章
	- 《从语义到面向对象的数据建模》
- 后来在 
	- 1983 年 
	- James Martin 所著的
	- 《管理数据库环境》一书中首次广为人知
- 除了CRUD 还有其他说法
    - CRUDL：创建 (create)、读取 (read)、更新 (update)、删除 (delete)、列表 (listing)
    - BREAD：浏览 (browse)、读取 (read)、编辑 (edit)、添加 (add)、删除 (delete)
    - DAVE：删除 (delete)、添加 (add)、预览 (view)、编辑 (edit)
    - CRAP：创建 (create)、复制 (replicate)、追加 (append)、处理 (process)

### 最后统一到CRUD这种说法

- CURD 设计之初是为了增强数据库的持久性存储
	- 而在现代软件开发中
	- 为 SQL、DDS 和 HTTP 协议等应用程序提供了设计原则


| 名称 | C | R | U | D |
| --- | --- | --- | --- | --- |
| 全名 | CREATE | READ | UPDATE | DELETE |
| 含义 | 增 | 查 | 改 | 删 |
| SQL命令 | INSERT | SELECT | UPDATE | DELETE |

- 这个语境发生在互联网之前
	- 使用编程语言 让对象 持久化在 数据库中
	- 这让编程层面的业务逻辑 和 数据库层面的数据存储 分出两层
- 服务器从逻辑到物理上分离
	- 业务逻辑服务器
	- 数据库服务器
	- 他们之间的逻辑是由开发人员编写程序实现的

### 2000年网络普及之后

-  2000 年
	-  网络上提供各种数据服务  
	-  但开发人员并没有一个用来开发网络 API 的标准
	-  独立分别 自创了一大堆不同的协议
	-  协议大都复杂繁琐、难以执行、不统一

-  Roy Fielding 和他的同事一起开发了 协议
	-  进而允许两个服务器能在全球范围内交换数据
- 这个协议就是REST

### REST

- `REST` 协议的创始人Roy Fielding 
	- 将 `REST`描述为分布式超媒体系统内架构元素的抽象化
	- `RE`presentational`S`tate`T`ransfer
- REST 架构风格
	- 为网络系统开发提供了统一的标准
	- 并规定了系统的互动方式
	- https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation_2up.pdf

### REST 有六个约束条件

1. 统一接口

- 统一接口的四个指导原则是
	1. 资源识别：
		- 每个资源都有一个资源标识
		- 且每个资源的资源标识可以用来唯一地标明该资源
	2. 通过表述来操作资源
		- 这里的表述是对自身的表述
		- 一个 REST 服务不需要额外的文档对如何操作资源进行说明
	3. 自描述的信息在 REST 		 		  
		- 系统中传递消息时还要能提供自身如何被处理的信息
		- 例如该消息所使用的 MIME 类型
		- 是否可以被缓存等
	4. 超媒体作为应用状态的引擎
		- 客户端通过协议主体内容、查询字符串参数、请求头和请求 URI（资源名称）传递状态
		- 服务端通过协议主体内容、状态码和响应头向客户提供状态

### REST 的六个约束条件2

2. 客户/服务器模型（CS 架构）
	- 通信只能由客户端单方面发起
	- 表现为请求-响应的形式
	- 客户-服务器模型约束背后的原则是关注点的分离
	- 即分离用户界面和数据存储两个关注点
	- 这有助于客户端和服务器的独立发展
	- 同时改善了用户界面跨平台的可移植性和可扩展性

3. 无状态

	- 无状态规定
	- 从客户端到服务器的每个请求必须包含理解和完成该请求所需的全部信息
	- 不能利用任何存储在服务器端的上下文
	- 所以 会话状态要全部保存在客户端

4. 缓存

	- 缓存是为了改善网络效率而提出的
	- 缓存要求服务器的响应中的数据被隐式地或显式地标记为可缓存或不可缓存
	- 例如，如果响应是可缓存的
		- 那么以后再遇到相同的请求该相应数据可重复利用
		- 304状态码

5. 分层系统

	- 分层系统通过限制层次之间的行为
		- 例如每一层对其他层都是只读的
		- 来将架构分解为若干层级
	- 每个层级之间都有一定的独立性
	- 中间层次还支持通过实现负载平衡和共享缓存
		- 来提高系统的可扩展性。

6. 按需代码(Code-On-Demand 可选)

	- 客户端可以下载运行服务端传来的代码
		- 比如 JavaScript
		- 通过减少一些功能简化了客户端

### 发展

- 这样基于http协议的RESTful风格的的io
	- 就成了互联网时代CRUD的典型代表

| 名称 | C | R | U | D |
| --- | --- | --- | --- | --- |
| 全名 | CREATE | READ | UPDATE | DELETE |
| 含义 | 增 | 查 | 改 | 删 |
| http请求方法(method) | POST | GET | UPDATE | DELETE |
| SQL命令 | INSERT | SELECT | UPDATE | DELETE |

## 总结
- 这次了解了CRUD
	- 数据持久层的增查改删操作
	- 最早是基于各种自定义的数据存储格式
	- 后来基于数据库统一用sql语言来操作
	- 到了互联网时代基于url完成操作
- 我们的这个应用还不能进行查询
	- 如何才能实现查询效果呢？🤔
- 下次再说！👋🏻