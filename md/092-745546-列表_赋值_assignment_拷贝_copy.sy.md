---
show: step
version: 1.0
enable_checker: true
---

# 列表 - 切片 - 赋值 - assignment

## 回忆

- 上次研究的是del
	- 删除
	- 可以删除列表项
	- 也可以把一段切片择出去
- 就像择菜一样

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669113091247)

- del把不要的菜从列表里面剔除出去
- 择出去的菜就消失了吗？🤔

### 地址

- 帧上存着 l 的 引用的地址(id)
	- 也只能看见 l

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220903-1662164129442)

- l[0]、l[1]、l[2]是在堆(heap)申请的内存
	- 并且将引用(id) 存储在 l 中的列表项中
		- 可以用l来访问l[0]
		- 可以看到id(l[0]) 引用的就是 
			- "刘备" 在堆空间的地址
- 切片应该如何理解呢？

### 观察

- 切片

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630224932111)

- 切片切完了之后
	- 如果没有被赋给任何对象
		- 也就消失了
	- 但如果把切片信息给一个列表变量
		- 这个切片就保留下来了
- 修改切片会影响原始列表吗？

### 修改切片

- 新的切片有自己独立的存储空间

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669121650271)

- 对新切片对象的操作不影响原来的切片
- 那如何让列表能互相影响呢？

### 互相影响

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669123282969)

- 为啥l1、l2会相互影响？
- 因为这种赋值的方法
- 我们去看看变量具体的值

### id

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669123385853)

- 这两个变量名l1、l2指向的是同一个列表对象地址
- 所以不论谁append
- 都会append到这个列表上
- 我可以看到这个列表对象被引用的次数吗？

### getrefcount

- getrefcount可以得到 堆heap中的 对象
	- 到底由 几个变量名 进行引用



- 明明是 l1 1个变量引用啊
- 为什么显示为2呢？

### 帮助手册

- 本来确实应该是1个
	- 但是由于这个函数调用的时候
	- 在函数内部还有一个参数变量也引用了这个位置
	- 所以会比想象地变量多 1

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210905-1630830139942)

- 每次getrefcount被调用的时候
	- 临时增加一个引用
	- 调用完了就释放

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669123647436)

- 这时候如果再把l1引用的地址修改成别的地址
	- 那[1, 2, 3]这个列表对象就没有人引用了
	- 系统垃圾回收装置就该回收他了
- 如果我想将 l2 做成 l1的副本
- 但是分别引用不同的地址空间
- 应该如何呢？


### copy 函数

- 所谓副本
	- 就是拷贝

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210731635)

- 返回列表的浅拷贝
	- shallow copy(浅拷贝)是什么意思？
		- 还不清楚
		- 难道还有深拷贝不成？
- 先了解什么是拷贝？

### copy

- 这个单词源于中世纪时候抄写文字
	- 后来也表示胶片的拷贝
	- 制片公司其实卖的是拷贝

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220728-1658976784346)

- 后来有了复印机指的是复印
	- 到了电脑时代
	- 复制文件就是cp(copy)
	- 具体来试试

### 验证

- 拷贝明白了
	- 两个列表分别的引用两个位置

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210829-1630210778781)

- 怎么确保这两个列表不指向同一个对象呢？

### 确保

- 观察id
	- 这两个列表确实id不同

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669124490608)

- 只要id不同
	- 引用的就是不同的地址空间
- 还有其他制作副本的方法吗？

### 制作副本方法2

- 使用list的构造函数
	- 根据l1再构造一个l2

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669124730716)

- 确实id不同
- 还有其他制作副本的方法吗？

### 制作副本的方法3

- 使用切片

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221122-1669124769593)

- 确实id也不同
- 目前我就想到这三种方法
- 你还有其他的方法么？

### 总结🤔
- 赋值运算
  - 直接用列表引用的地址赋值
	- 造成两个列表指向同一个对象
		- 一荣俱荣
		- 一损俱损
		- 所有操作都会作用到一个对象上
  - 如果将列表副本赋给变量
	- 这两个列表变量指向不同的对象
	- 互不影响
	- 制作副本的3种方法
		- copy拷贝
		- list构造
		- slice切片
- 赋值运算符号=很简单
	- 但是由于等号右边的对象不同
	- 还是有很多细节的
- 还有什么好玩的细节呢？
- 列表可以做加法吗？🤔
	- 比如l1 + l2

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221115-1668500786899)

- 下次再说 👋
