---
show: step
version: 1.0
enable_checker: true
---

# 浮点类型

## 回忆

- 上次观察 取整方式
	- int 函数 
		- 截断取整
		- 直接去掉小数位
	- 整除 得到商 和 余数
		- 向下地板取整
	- divmod
		- 同 // 和 %
- 如果 用一般除法
	- 不用整除的话 会如何呢？

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221203-1670073626312)

- 不用整除的话
	- 商的类型是 是浮点小数

- 为什么之前 有的小数
	- 会忽略 小数部分 呢？🤪

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211030-1635580692141)

- 这 浮点小数
	- 到底 是怎么 存进字节的 呢？

## 精度问题

- 问题出现

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211003-1633222609130)

- 真的发生了
  - 浮点型数字精度低于整型数字
- 为什么呢？

### 浮点型格式

- 浮点数表示法
  - 单精度浮点型数字只有 4 个字节
  - 双精度浮点型数字有 8 个字节
  - 有效数字位数有限
  - 所以...

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231006-1696556831689)

- 浮点型数字被截断了...
  - 最上面的图可以看出丢失了一位精度
  - 而且最后一位 9 还给舍了
- 具体是怎么截断的呢？
- 去帮助 查一下float类
	- help(float)

### 浮点类型 float

- float原意是浮动
	- 浮动的东西 是小数点
	- 所以float类 也叫 浮点数类

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211029-1635515488500)

- float 类里面
	- 有个成员函数 hex
- help(float.hex)
	- 查找float.hex的帮助


### 二进制形态

- float的东西 是 point
	- 浮动的对象 是 小数点

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629446954069)

- p 的意思就是小数点 point
	- p 前面的是有效数字
	  - 可以有正负号
	  - 0x 说明是 16 进制的表示法
	- p 后面是指数
	  - 小数点浮动位置
	  - $-4$ 就是左移 4 位
	  - $+1$ 就是右移 1 位
	  - 指数变化会造成数量级的翻番
	    - 在 2 的底数基础上翻番

### 科学计数法的好处

- 这种表示法就像我们的科学计数法
	- 3e8
	- 相当于3*10<sup>8</sup>

- 指数的加减
	- 就 对应 小数点的浮动

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231005-1696513281524)

- 最终 将这3部分 依次放入 
	- 32-bit
	- 4-byte

### 验证

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231005-1696513519258)

- 我们先看看
	- 最简单的1是如何存储的

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231005-1696513568367)

- 在字节序方面
	- 我们选择>f
	- 大字节序

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231005-1696513688816)

- $1.0$ 对应 `\x3f\x80\x00\x00`
	- 这个规则叫做 ieee754 32-bit 浮点数规则
	- 将 浮点数 存储在四个字节
- 在哪里可以验证吗？

### 1.0的存储

- http://www.binaryconvert.com/result_float.html?hexadecimal=3F800000

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646725113755)

- 最前面的 是 符号位
	- 0 代表正数
- 中间的 exponent 是 指数部分
	- 指数部分的加减
		- 负责让数字翻倍或折半
		- 让数字可以表达的范围增大
	- 平衡位置在01111111
		- 目前刚好是平衡位置 
			- 不加不减
- mantissa 尾数部分
	- 在前面默认 省略了 一个1
		- 负责数字的有效数字位数
		- 从而确保提高数字的精度
	- 指数后面的都是有效数字
	- 目前这个相当于只有1
- 结果是 
	- 1 x 2<sup>0</sup>
	- 1


## 继续验证

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629447904479)

- 三部分
	1. 符号位 为0 正数
	2. 指数部分为平衡位置+1 
	3. 尾数部分 依然是0 有效数字为1.0 

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646725740719)

- $2.0$ 和 $1.0$ 相比
  - 尾数部分没有变化
  - 指数部分 $+1$
	  - 小数点浮动了一位

### **$4.0$：**

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448017365)

- 三部分
	1. 符号位 为0 正数
	2. 指数部分为平衡位置+2 
	3. 尾数部分 依然是0 有效数字为1.0 

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646733947511)

- $4.0$ 和 $2.0$ 相比
  - 又 $x2$
  - 相当于指数 $+1$
  - 尾数没有变化
- 如果是 $0.5$ 呢？

### **$0.5$：**

- $0.5$ 是在 $1.0$ 的基础上除以 2
- 相当于在 $1.0$ 的指数部分 $-1$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448317994)

- 三部分
	1. 符号位 为0 正数
	2. 指数部分为平衡位置-1 
	3. 尾数部分 依然是0 有效数字为1.0 

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646737762598)

- 指数部分从 $1.0$ 的 `\x3f\x80` 
	- 到 $0.5$ 的 `\x3f\x00`

### 尾数部分

- 尾数怎么用呢？
	- 然后观察 $1.5$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646737975921)

- 三部分
	1. 符号位 为0 正数
	2. 指数部分为平衡位置
	3. 尾数部分 (1.1)<sub>2进制</sub> 

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448678597)

- $1.5$ 和 $1.0$ 相比
  - 指数没有变化
	- 小数点不用移动
  - 尾数把第一位改成了 1
	- 加上原来默认的1得到 $(1.1)$ <sub>2进制</sub>
- $(1.1)$ <sub>2进制</sub> 等于 $(1.5)$<sub>10进制</sub>

### 3

- $3.0$ 和 $1.5$ 相比
  - 尾数没有变化
  - 指数 $+1$
  - 相当于乘以 $2$

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646738153003)

- 三部分
	1. 符号位 为0 正数
	2. 指数部分为 平衡位置 +1
	3. 尾数部分 (1.1)<sub>2进制</sub> 

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448861896)

## 负数呢

- $-3.0$ 和 $3.0$ 相比
  - 指数和尾数都没有变化
  - 符号位从 $0$ 变 $1$
  - 意味着这是负数

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20221029-1667040006341)

- 2进制的0.1
	- 相当于10进制的0.5
- 2进制的1.1
	- 相当于10进制的1.5

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20210820-1629448962448)

- 翻倍就得到3
- 请自己练习-5

### 练习

- 这个 -5 应该如何理解

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220308-1646738330134)

- 底数 是 $(1.01)$ <sub>2进制</sub> 
- 指数是 2<sup>2</sup> 

### 回到最初

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20211003-1633222609130)

- 是如何存储的呢？

### 存储方式

- 我们前面介绍的都是单精度浮点型 float
  - 单精度浮点型 float 总共 4-byte
- 还有一种 双精度浮点型
	- double
    - 使用 8-byte 存储

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20220731-1659258628034)

- 受到尾数精度限制
	- 最后面的那个九被截取
	- 消失了
- 具体怎么做的呢？

### 取整过程

- 指数部分是

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231005-1696514443349)

- 尾数部分是
	- (1.01000011 01111011 01101001 10110100 10111010 11001101 00000101 11110001)<sub>2进制</sub>

![图片描述](https://doc.shiyanlou.com/courses/uid1190679-20231005-1696514565159)

- 这个过程也就是
	- 123456789123456789 
		- 被截取精度的过程
	- 也是浮点数 
		- 必须要落实到 双浮点型规定的 8-byte 的过程

### 浮点数总结

- 浮点数有三个部分组成
  - 符号位
    - 负责正负
    - $0$ 就是正
    - $1$ 就是负
  - 指数部分
    - 负责翻倍
    - 以 $01111111$ 为平衡位置
    - $+1$ 相当于乘以 $2$
    - $-1$ 相当于除以 $2$
  - 尾数部分
    - 前面有一个 $1$ 不显示
    - 默认就是 $1.0$
    - 第一位写一个 $1$ 代表 $1.1$
    - 第二位再写一个 $1$ 代表 $1.11$

- 浮点数类型的对应的float
	- 究竟应该如何理解呢？🤔
- 下次再说 👋
